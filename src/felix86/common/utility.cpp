#include <cstring>
#include <fstream>
#include <sys/ioctl.h>
#include "Zydis/Decoder.h"
#include "Zydis/Disassembler.h"
#include "felix86/common/debug.hpp"
#include "felix86/common/elf.hpp"
#include "felix86/common/state.hpp"
#include "felix86/common/utility.hpp"
#include "fmt/format.h"

#ifdef __riscv
#include <sys/cachectl.h>
#endif

struct fxsave_st {
    u8 st[10];
    u8 reserved[6];
};

struct fxsave_data {
    u16 fcw;
    u16 fsw;
    u8 ftw;
    u8 reserved;
    u16 fop;
    u64 fip;
    u64 fdp;
    u32 mxcsr;
    u32 mxcsr_mask;
    fxsave_st st[8];
    XmmReg xmms[16];
    u64 reserved_final[6];
    u64 available[6];
};
static_assert(sizeof(fxsave_data) == 512);

/* Libdivide LICENSE


  Copyright (C) 2010 - 2019 ridiculous_fish, <libdivide@ridiculousfish.com>
  Copyright (C) 2016 - 2019 Kim Walisch, <kim.walisch@gmail.com>

  Boost Software License - Version 1.0 - August 17th, 2003

  Permission is hereby granted, free of charge, to any person or organization
  obtaining a copy of the software and accompanying documentation covered by
  this license (the "Software") to use, reproduce, display, distribute,
  execute, and transmit the Software, and to prepare derivative works of the
  Software, and to permit third-parties to whom the Software is furnished to
  do so, all subject to the following:

  The copyright notices in the Software and this entire statement, including
  the above license grant, this restriction and the following disclaimer,
  must be included in all copies of the Software, in whole or in part, and
  all derivative works of the Software, unless such copies or derivative
  works are solely in the form of machine-executable object code generated by
  a source language processor.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

*/
// libdivide_128_div_64_to_64: divides a 128-bit uint {numhi, numlo} by a 64-bit uint {den}. The
// result must fit in 64 bits. Returns the quotient directly and the remainder in *r
static inline uint64_t libdivide_128_div_64_to_64(uint64_t numhi, uint64_t numlo, uint64_t den, uint64_t* r) {
    // N.B. resist the temptation to use __uint128_t here.
    // In LLVM compiler-rt, it performs a 128/128 -> 128 division which is many times slower than
    // necessary. In gcc it's better but still slower than the divlu implementation, perhaps because
    // it's not LIBDIVIDE_INLINEd.
    // We work in base 2**32.
    // A uint32 holds a single digit. A uint64 holds two digits.
    // Our numerator is conceptually [num3, num2, num1, num0].
    // Our denominator is [den1, den0].
    const uint64_t b = ((uint64_t)1 << 32);

    // The high and low digits of our computed quotient.
    uint32_t q1;
    uint32_t q0;

    // The normalization shift factor.
    int shift;

    // The high and low digits of our denominator (after normalizing).
    // Also the low 2 digits of our numerator (after normalizing).
    uint32_t den1;
    uint32_t den0;
    uint32_t num1;
    uint32_t num0;

    // A partial remainder.
    uint64_t rem;

    // The estimated quotient, and its corresponding remainder (unrelated to true remainder).
    uint64_t qhat;
    uint64_t rhat;

    // Variables used to correct the estimated quotient.
    uint64_t c1;
    uint64_t c2;

    // Check for overflow and divide by 0.
    if (numhi >= den) {
        if (r)
            *r = ~0ull;
        return ~0ull;
    }

    // Determine the normalization factor. We multiply den by this, so that its leading digit is at
    // least half b. In binary this means just shifting left by the number of leading zeros, so that
    // there's a 1 in the MSB.
    // We also shift numer by the same amount. This cannot overflow because numhi < den.
    // The expression (-shift & 63) is the same as (64 - shift), except it avoids the UB of shifting
    // by 64. The funny bitwise 'and' ensures that numlo does not get shifted into numhi if shift is
    // 0. clang 11 has an x86 codegen bug here: see LLVM bug 50118. The sequence below avoids it.
    shift = __builtin_clzll(den);
    den <<= shift;
    numhi <<= shift;
    numhi |= (numlo >> (-shift & 63)) & (-(int64_t)shift >> 63);
    numlo <<= shift;

    // Extract the low digits of the numerator and both digits of the denominator.
    num1 = (uint32_t)(numlo >> 32);
    num0 = (uint32_t)(numlo & 0xFFFFFFFFu);
    den1 = (uint32_t)(den >> 32);
    den0 = (uint32_t)(den & 0xFFFFFFFFu);

    // We wish to compute q1 = [n3 n2 n1] / [d1 d0].
    // Estimate q1 as [n3 n2] / [d1], and then correct it.
    // Note while qhat may be 2 digits, q1 is always 1 digit.
    qhat = numhi / den1;
    rhat = numhi % den1;
    c1 = qhat * den0;
    c2 = rhat * b + num1;
    if (c1 > c2)
        qhat -= (c1 - c2 > den) ? 2 : 1;
    q1 = (uint32_t)qhat;

    // Compute the true (partial) remainder.
    rem = numhi * b + num1 - q1 * den;

    // We wish to compute q0 = [rem1 rem0 n0] / [d1 d0].
    // Estimate q0 as [rem1 rem0] / [d1] and correct it.
    qhat = rem / den1;
    rhat = rem % den1;
    c1 = qhat * den0;
    c2 = rhat * b + num0;
    if (c1 > c2)
        qhat -= (c1 - c2 > den) ? 2 : 1;
    q0 = (uint32_t)qhat;

    // Return remainder if requested.
    if (r)
        *r = (rem * b + num0 - q0 * den) >> shift;
    return ((uint64_t)q1 << 32) | q0;
}

void felix86_div128(ThreadState* state, u64 divisor) {
    // TODO: make this use the above function too, see __divti4
    ASSERT(divisor != 0);
    __int128_t dividend = ((__int128_t)state->gprs[X86_REF_RDX - X86_REF_RAX] << 64) | state->gprs[X86_REF_RAX - X86_REF_RAX];
    u64 quotient = dividend / (i64)divisor;
    u64 remainder = dividend % (i64)divisor;
    state->gprs[X86_REF_RAX - X86_REF_RAX] = quotient;
    state->gprs[X86_REF_RDX - X86_REF_RAX] = remainder;
}

void felix86_divu128(ThreadState* state, u64 divisor) {
    ASSERT(divisor != 0);
    u64 remainder;
    u64 quotient = libdivide_128_div_64_to_64(state->gprs[X86_REF_RDX - X86_REF_RAX], state->gprs[X86_REF_RAX - X86_REF_RAX], divisor, &remainder);
    state->gprs[X86_REF_RAX - X86_REF_RAX] = quotient;
    state->gprs[X86_REF_RDX - X86_REF_RAX] = remainder;
}

u64 sext(u64 value, u8 size) {
    switch (size) {
    case X86_SIZE_BYTE:
        return (i64)(i8)value;
    case X86_SIZE_WORD:
        return (i64)(i16)value;
    case X86_SIZE_DWORD:
        return (i64)(i32)value;
    case X86_SIZE_QWORD:
        return value;
    default:
        UNREACHABLE();
        return 0;
    }
}

u64 sext_if_64(u64 value, u8 size_e) {
    switch (size_e) {
    case X86_SIZE_BYTE:
    case X86_SIZE_WORD:
    case X86_SIZE_DWORD:
        return value;
    case X86_SIZE_QWORD:
        return (i64)(i32)value;
    default:
        ERROR("Invalid immediate size");
        return 0;
    }
}

// If you don't flush the cache the code will randomly SIGILL
void flush_icache() {
#if defined(__riscv)
    asm volatile("fence.i");
#endif
}

// Flush icache to other cores as well
void flush_icache_global(const HostAddress& start, const HostAddress& end) {
#if defined(__riscv)
    __riscv_flush_icache((void*)start.raw(), (void*)end.raw(), 0);
#endif
}

int guest_breakpoint(const char* region, u64 address) {
    auto [start, end] = MemoryMetadata::GetRegionByName(region);

    if (start == 0 && end == 0) {
        WARN("Region %s not found, breakpoint will be added later if loaded", region);
        MemoryMetadata::AddDeferredBreakpoint(region, address);
        return -1;
    }

    if (address >= (end - start)) {
        WARN("Address %016lx is out of bounds for region %s", address, region);
        return -1;
    }

    g_breakpoints[address + start] = {};
    return g_breakpoints.size();
}

__attribute__((visibility("default"))) int guest_breakpoint_abs(u64 address) {
    g_breakpoints[address] = {};
    return g_breakpoints.size();
}

__attribute__((visibility("default"))) void disassemble_x64(u64 address) {
    // in 32-bit mode we like to be able to provide a guest address to gdb when calling this function
    HostAddress host_address = GuestAddress{address}.toHost();

    ZydisDecoder decoder;
    ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64);

    u64 cur = host_address.raw();
    while (true) {
        ZydisDecodedInstruction instruction;
        ZydisDecodedOperand operands[10];
        ZyanStatus status = ZydisDecoderDecodeFull(&decoder, (void*)cur, 15, &instruction, operands);
        if (!ZYAN_SUCCESS(status)) {
            printf("Failed to decode instruction at %016lx\n", cur);
            break;
        }

        ZydisMnemonic mnemonic = instruction.mnemonic;
        bool is_jump = instruction.meta.branch_type != ZYDIS_BRANCH_TYPE_NONE;
        bool is_ret = mnemonic == ZYDIS_MNEMONIC_RET;
        bool is_call = mnemonic == ZYDIS_MNEMONIC_CALL;
        bool is_illegal = mnemonic == ZYDIS_MNEMONIC_UD2;
        bool is_hlt = mnemonic == ZYDIS_MNEMONIC_HLT;
        bool stop = is_jump || is_ret || is_call || is_illegal || is_hlt;

        ZydisDisassembledInstruction instr;
        ZydisDisassembleIntel(ZYDIS_MACHINE_MODE_LONG_64, cur, (void*)cur, 15, &instr);

        printf("%016lx: %s\n", cur, instr.text);

        if (stop) {
            break;
        } else {
            cur += instruction.length;
        }
    }
}

int clear_breakpoints() {
    int count = g_breakpoints.size();
    g_breakpoints.clear();
    return count;
}

void felix86_fxsave(struct ThreadState* state, u64 address, bool fxsave64) {
    fxsave_data* data = (fxsave_data*)address;
    memset(data, 0, sizeof(fxsave_data));

    for (int i = 0; i < 16; i++) {
        data->xmms[i] = state->xmm[i];
    }

    for (int i = 0; i < 8; i++) {
        Float80 f = f64_to_80(state->fp[i]);
        memcpy(&data->st[i].st[0], &f, 10);
    }

    data->fcw = state->fpu_cw;
    data->ftw = state->fpu_tw;
    data->fsw = state->fpu_top << 11;
    data->mxcsr = state->mxcsr;
}

void felix86_fxrstor(struct ThreadState* state, u64 address, bool fxrstor64) {
    fxsave_data* data = (fxsave_data*)address;

    for (int i = 0; i < 16; i++) {
        state->xmm[i] = data->xmms[i];
    }

    for (int i = 0; i < 8; i++) {
        Float80 f;
        memcpy(&f, &data->st[i].st[0], 10);
        state->fp[i] = f80_to_64(f);
    }

    state->fpu_cw = data->fcw;
    state->fpu_tw = data->ftw;
    state->fpu_top = (data->fsw >> 11) & 7;
    state->mxcsr = data->mxcsr;
    state->rmode = rounding_mode((x86RoundingMode)((state->mxcsr >> 13) & 3));
}

void felix86_packuswb(u8* dst, u8* src) {
    ASSERT(((u64)dst & 1) == 0);
    ASSERT(((u64)src & 1) == 0);
    i16* src16 = (i16*)src;
    i16* dst16 = (i16*)dst;
    u8 temp[16];
    for (int i = 0; i < 8; i++) {
        i16 value = *dst16++;
        u8 result;
        if (value < 0) {
            result = 0;
        } else if (value > 255) {
            result = 255;
        } else {
            result = (u8)value;
        }
        temp[i] = result;
    }

    for (int i = 8; i < 16; i++) {
        i16 value = *src16++;
        u8 result;
        if (value < 0) {
            result = 0;
        } else if (value > 255) {
            result = 255;
        } else {
            result = (u8)value;
        }
        temp[i] = result;
    }
    memcpy(dst, temp, 16);
}

void felix86_packusdw(u16* dst, u8* src) {
    ASSERT(((u64)dst & 3) == 0);
    ASSERT(((u64)src & 3) == 0);
    i32* src32 = (i32*)src;
    i32* dst32 = (i32*)dst;
    u16 temp[8];
    for (int i = 0; i < 4; i++) {
        i32 value = *dst32++;
        u16 result;
        if (value < 0) {
            result = 0;
        } else if (value > 0xFFFF) {
            result = 0xFFFF;
        } else {
            result = (u16)value;
        }
        temp[i] = result;
    }

    for (int i = 4; i < 8; i++) {
        i32 value = *src32++;
        u16 result;
        if (value < 0) {
            result = 0;
        } else if (value > 0xFFFF) {
            result = 0xFFFF;
        } else {
            result = (u16)value;
        }
        temp[i] = result;
    }
    memcpy(dst, temp, 16);
}

void felix86_pmaddwd(i16* dst, i16* src) {
    ASSERT(((u64)dst & 1) == 0);
    ASSERT(((u64)src & 1) == 0);
    i32 temp[4];
    i32 result[4];

    temp[0] = dst[0] * src[0];
    temp[1] = dst[2] * src[2];
    temp[2] = dst[4] * src[4];
    temp[3] = dst[6] * src[6];

    result[0] = dst[1] * src[1];
    result[1] = dst[3] * src[3];
    result[2] = dst[5] * src[5];
    result[3] = dst[7] * src[7];

    u32* dst32 = (u32*)dst;
    dst32[0] = temp[0] + result[0];
    dst32[1] = temp[1] + result[1];
    dst32[2] = temp[2] + result[2];
    dst32[3] = temp[3] + result[3];
}

void felix86_psadbw(u8* dst, u8* src) {
    u64 result1 = 0;
    u64 result2 = 0;

    for (int i = 0; i < 8; i++) {
        result1 += abs(dst[i] - src[i]);
        result2 += abs(dst[i + 8] - src[i + 8]);
    }

    u64* dst64 = (u64*)dst;
    dst64[0] = (u16)result1;
    dst64[1] = (u16)result2;
}

void dump_states() {
    auto lock = g_process_globals.states_lock.lock();
    auto& states = g_process_globals.states;
    int i = 0;
    for (auto& state : states) {
        dprintf(g_output_fd, ANSI_COLOR_RED "State %d (%ld):" ANSI_COLOR_RESET "\n", i, state->tid);
        print_address(state->rip.toHost().raw());

        if (g_calltrace) {
            auto it = state->calltrace.rbegin();
            while (it != state->calltrace.rend()) {
                print_address((*it).raw());
                it++;
            }
        }
        i++;
    }
}

void update_symbols() {
    if (g_symbols_cached) {
        return;
    }

    auto lock = g_process_globals.symbols_lock.lock();
    g_process_globals.mapped_regions.clear();
    g_process_globals.symbols.clear();

    std::ifstream ifs("/proc/self/maps");
    std::string line;
    char buffer[PATH_MAX];
    std::map<std::string, std::pair<u64, u64>> regions{};
    while (std::getline(ifs, line)) {
        u64 start, end;
        int result = sscanf(line.c_str(), "%lx-%lx %*s %*s %*s %*s %s", &start, &end, buffer);
        if (result == 3) {
            if (!std::filesystem::is_regular_file(buffer)) {
                // Not a regular file, either a library outside the chroot or something like
                // /dev/zero, so we don't add it
                continue;
            }

            auto it = regions.find(buffer);
            if (it == regions.end() && Elf::Peek(buffer) == Elf::PeekResult::NotElf) {
                continue;
            }

            if (std::string(buffer).find("/felix86") == 0) {
                // It's our emulator or its libraries, skip
                continue;
            }

            if (it == regions.end()) {
                regions[buffer] = {UINT64_MAX, 0};
            }

            std::pair<u64, u64>& region = regions[buffer];
            u64 new_start = std::min(region.first, start);
            u64 new_end = std::max(region.second, end);
            region.first = new_start;
            region.second = new_end;
        } else {
            // Failed to parse, is not a map line with a path, skip
        }
    }

    for (auto& region : regions) {
        std::string name = region.first;
        u64 start = region.second.first;
        u64 end = region.second.second;

        g_process_globals.mapped_regions[end - 1] = {.base = start, .end = end, .file = name};
        Elf::AddSymbols(g_process_globals.symbols, name, (u8*)start, (u8*)end);
    }

    g_symbols_cached = true;
}

std::string get_region(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();
    auto it = g_process_globals.mapped_regions.lower_bound(address);
    if (address >= it->second.base) {
        return it->second.file;
    } else {
        return "Unknown";
    }
}

bool has_region(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();
    auto region_it = g_process_globals.mapped_regions.lower_bound(address);
    if (region_it == g_process_globals.mapped_regions.end()) {
        return false;
    }

    if (address >= region_it->second.base && address <= region_it->second.end) {
        return true;
    }

    return false;
}

std::string get_perf_symbol(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();
    auto symbol_it = g_process_globals.symbols.lower_bound(address);

    Symbol* symbol = nullptr;
    if (symbol_it != g_process_globals.symbols.end()) {
        u64 start = symbol_it->second.start;
        u64 end = symbol_it->second.start + symbol_it->second.size;
        if (address >= start && address <= end) {
            symbol = &symbol_it->second;
        }
    }

    bool file_found = false;
    std::string file = "??";
    u64 file_offset = address;
    auto region_it = g_process_globals.mapped_regions.lower_bound(address);
    if (region_it != g_process_globals.mapped_regions.end()) {
        u64 start = region_it->second.base;
        u64 end = region_it->second.end;
        if (address >= start && address <= end) {
            file_found = true;
            file = std::filesystem::path(region_it->second.file).filename();

            if (file.size() > 20) {
                file = file.substr(0, 19);
                file += "...";
            }

            file_offset = address - region_it->second.base;
        }
    }

    const char* x86 = g_mode32 ? "x86" : "x86_64";
    std::string ret;
    if (symbol) {
        std::string symbol_name = symbol->name;
        if (symbol_name.size() > 30) {
            symbol_name = symbol_name.substr(0, 29);
            symbol_name += "...";
        }

        ret = fmt::format("{} {}@0x{:x} {}@0x{:x}", x86, file, file_offset, symbol->name, address - symbol->start);
    } else if (file_found) {
        ret = fmt::format("{} {}@0x{:x}", x86, file, file_offset);
    } else {
        ret = fmt::format("{} 0x{:x}", x86, address);
    }

    return ret;
}

void print_address(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();

    bool found = false;
    MappedRegion region{};

    auto region_it = g_process_globals.mapped_regions.lower_bound(address);
    if (region_it != g_process_globals.mapped_regions.end()) {
        u64 start = region_it->second.base;
        u64 end = region_it->second.end;
        if (address >= start && address <= end) {
            region = region_it->second;
            found = true;
        }
    }

    if (!found) {
        region.base = address;
        region.end = address;
        region.file = "??";
    }

    Symbol* symbol = nullptr;
    auto symbol_it = g_process_globals.symbols.lower_bound(address);
    if (symbol_it != g_process_globals.symbols.end()) {
        u64 start = symbol_it->second.start;
        u64 end = symbol_it->second.start + symbol_it->second.size;
        if (address >= start && address <= end) {
            symbol = &symbol_it->second;
        } else {
            VERBOSE("Lower bound doesn't match address: %lx - %lx %s, address is %lx", start, end, symbol_it->second.name.c_str(), address);
        }
    } else {
        VERBOSE("Lower bound not found for address: %lx", address);
    }

    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);

    std::string filename = region.file;
    if (found) {
        filename = std::filesystem::path(region.file).filename();
    }

    const char* symbol_str = symbol ? symbol->name.c_str() : nullptr;
    std::string symbol_trunc;
    if (symbol_str) {
        // 16 for each hex number at most
        // 4 for " in "
        // 8 more for the parentheses stuff and other characters
        i64 max_size = 16 + 4 + filename.size() + 8 + 16;
        max_size = w.ws_col - max_size;
        max_size -= 8; // give it some extra breathing room too

        if (max_size < 10) {
            // If we have fewer than 10 characters, the user is just messing around with a tiny terminal or idk
            // Let's just not truncate it.
            symbol_trunc = symbol_str;
        } else {
            symbol_trunc = symbol_str;
            symbol_trunc = symbol_trunc.substr(0, max_size);
            symbol_trunc += "...";
        }
    }

    // clang-format can't comprehend what I am about to do
    // clang-format off
    std::string filename_offset;
    if (filename == "??") {
        filename_offset = filename;
    } else {
        filename_offset = fmt::format("{}+0x{:x}", filename, address - region.base);
    }

    if (symbol_str) {
        u64 offset = address - symbol->start;
        dprintf(g_output_fd,
            ANSI_COLOR_CYAN "%s+0x%lx" ANSI_COLOR_RESET " in " ANSI_COLOR_YELLOW "%s" ANSI_COLOR_RESET " (0x%lx)\n",
            symbol_trunc.c_str(),
            offset,
            filename_offset.c_str(),
            address
        );
    } else {
        dprintf(g_output_fd,
            ANSI_COLOR_CYAN "0x%lx" ANSI_COLOR_RESET " in " ANSI_COLOR_YELLOW "%s" ANSI_COLOR_RESET "\n",
            address,
            filename_offset.c_str()
        );
    }
    // clang-format on
}

void push_calltrace(ThreadState* state, u64 address) {
    state->calltrace.push_back(HostAddress{address});

    if (g_print_all_calls) {
        dprintf(g_output_fd, "Thread %ld calling: ", state->tid);
        print_address(state->rip.toHost().raw());
    }
}

void pop_calltrace(ThreadState* state) {
    if (state->calltrace.empty()) {
        return;
    }

    if (g_print_all_calls) {
        dprintf(g_output_fd, "Thread %ld returning: ", state->tid);
        print_address(state->rip.toHost().raw());
    }

    state->calltrace.pop_back();
}

Float80 f64_to_80(double x) {
    union {
        double d;
        uint64_t u;
    } conv;
    conv.d = x;

    uint16_t sign = (conv.u >> 63) & 0x1;
    int16_t exponent = (conv.u >> 52) & 0x7FF;
    uint64_t significand = conv.u & 0xFFFFFFFFFFFFF;

    Float80 result;

    if (exponent == 0) {
        result.signExp = sign << 15;
        result.significand = significand;
    } else if (exponent == 0x7FF) {
        result.signExp = (sign << 15) | 0x7FFF;
        result.significand = significand ? (1ULL << 63) | significand : 0;
    } else {
        exponent = exponent - 1023 + 16383;
        significand |= (1ULL << 52);
        significand <<= 11;

        result.signExp = (sign << 15) | (exponent & 0x7FFF);
        result.significand = significand;
    }

    return result;
}

double f80_to_64(Float80 f80) {
    union {
        double d;
        uint64_t u;
    } conv;

    uint16_t sign = (f80.signExp >> 15) & 0x1;
    int16_t exponent = f80.signExp & 0x7FFF;
    uint64_t significand = f80.significand;

    if (exponent == 0) {
        conv.u = ((uint64_t)sign << 63) | (significand >> 11);
    } else if (exponent == 0x7FFF) {
        conv.u = ((uint64_t)sign << 63) | ((uint64_t)0x7FF << 52) | (significand ? (significand >> 11) : 0);
    } else {
        exponent = exponent - 16383 + 1023;
        significand >>= 11;

        conv.u = ((uint64_t)sign << 63) | ((uint64_t)exponent << 52) | (significand & 0xFFFFFFFFFFFFF);
    }

    return conv.d;
}

bool felix86_bt(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 value = __atomic_load_n(ptr, __ATOMIC_SEQ_CST);
    return (value >> bit_offset) & 1;
}

bool felix86_bts(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 old = __atomic_fetch_or(ptr, 1 << bit_offset, __ATOMIC_SEQ_CST);
    return (old >> bit_offset) & 1;
}

bool felix86_btr(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 old = __atomic_fetch_and(ptr, ~(1 << bit_offset), __ATOMIC_SEQ_CST);
    return (old >> bit_offset) & 1;
}

bool felix86_btc(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 old = __atomic_fetch_xor(ptr, 1 << bit_offset, __ATOMIC_SEQ_CST);
    return (old >> bit_offset) & 1;
}

const char* print_exit_reason(int reason) {
    switch (reason) {
    case EXIT_REASON_HLT:
        return "Hlt instruction";
    case EXIT_REASON_EXIT_SYSCALL:
        return "Exit syscall";
    case EXIT_REASON_EXIT_GROUP_SYSCALL:
        return "Exit group syscall";
    }

    return "Unknown";
}